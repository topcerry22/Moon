{"version":3,"file":"three-to-cannon.modern.js","sources":["../lib/ConvexHull.js","../src/utils.ts","../src/index.ts"],"sourcesContent":["import {\n\tBufferGeometry,\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nvar ConvexHull = ( function () {\n\n\tvar Visible = 0;\n\tvar Deleted = 1;\n\n\tvar v1 = new Vector3();\n\n\tfunction ConvexHull() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tObject.assign( ConvexHull.prototype, {\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: Points parameter is not an array.' );\n\n\t\t\t}\n\n\t\t\tif ( points.length < 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.ConvexHull: The algorithm needs at least four points.' );\n\n\t\t\t}\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\tvar points = [];\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar i, l, point;\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry === undefined ) return;\n\n\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\tgeometry = geometry.toBufferGeometry\n\t\t\t\t\t\t? geometry.toBufferGeometry()\n\t\t\t\t\t\t: new BufferGeometry().fromGeometry( geometry );\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = new Vector3();\n\n\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.setFromPoints( points );\n\n\t\t},\n\n\t\tcontainsPoint: function ( point ) {\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\tintersectRay: function ( ray, target ) {\n\n\t\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\"  by Eric Haines, GRAPHICS GEMS II\n\n\t\t\tvar faces = this.faces;\n\n\t\t\tvar tNear = - Infinity;\n\t\t\tvar tFar = Infinity;\n\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tvar face = faces[ i ];\n\n\t\t\t\t// interpret faces as planes for the further computation\n\n\t\t\t\tvar vN = face.distanceToPoint( ray.origin );\n\t\t\t\tvar vD = face.normal.dot( ray.direction );\n\n\t\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\t\tvar t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t\t// lies \"behind\" the origin\n\n\t\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t\t//  plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// front-face\n\n\t\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// evaluate intersection point\n\n\t\t\t// always try tNear first since its the closer intersection point\n\n\t\t\tif ( tNear !== - Infinity ) {\n\n\t\t\t\tray.at( tNear, target );\n\n\t\t\t} else {\n\n\t\t\t\tray.at( tFar, target );\n\n\t\t\t}\n\n\t\t\treturn target;\n\n\t\t},\n\n\t\tintersectsRay: function ( ray ) {\n\n\t\t\treturn this.intersectRay( ray, v1 ) !== null;\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.faces = [];\n\t\t\tthis.vertices = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\t\taddVertexToFace: function ( vertex, face ) {\n\n\t\t\tvertex.face = face;\n\n\t\t\tif ( face.outside === null ) {\n\n\t\t\t\tthis.assigned.append( vertex );\n\n\t\t\t} else {\n\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t\t}\n\n\t\t\tface.outside = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\t\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\t\tif ( vertex === face.outside ) {\n\n\t\t\t\t// fix face.outside link\n\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\t\tface.outside = vertex.next;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\t\tface.outside = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.assigned.remove( vertex );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\t\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\t\tif ( face.outside !== null ) {\n\n\t\t\t\t// reference to the first and last vertex of this face\n\n\t\t\t\tvar start = face.outside;\n\t\t\t\tvar end = face.outside;\n\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\t\tend = end.next;\n\n\t\t\t\t}\n\n\t\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t\t// fix references\n\n\t\t\t\tstart.prev = end.next = null;\n\t\t\t\tface.outside = null;\n\n\t\t\t\treturn start;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Removes all the visible vertices that 'face' is able to see\n\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\t\tif ( faceVertices !== undefined ) {\n\n\t\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t\t} while ( vertex !== null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\t\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Computes the extremes of a simplex which will be the initial hull\n\n\t\tcomputeExtremes: function () {\n\n\t\t\tvar min = new Vector3();\n\t\t\tvar max = new Vector3();\n\n\t\t\tvar minVertices = [];\n\t\t\tvar maxVertices = [];\n\n\t\t\tvar i, l, j;\n\n\t\t\t// initially assume that the first vertex is the min/max\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t\t}\n\n\t\t\tmin.copy( this.vertices[ 0 ].point );\n\t\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t\t// compute the min/max vertex on all six directions\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvar point = vertex.point;\n\n\t\t\t\t// update the min coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the max coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t\t);\n\n\t\t\treturn { min: minVertices, max: maxVertices };\n\n\t\t},\n\n\t\t// Computes the initial simplex assigning to its faces all the points\n\t\t// that are candidates to form part of the hull\n\n\t\tcomputeInitialHull: function () {\n\n\t\t\tvar line3, plane, closestPoint;\n\n\t\t\treturn function computeInitialHull() {\n\n\t\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\t\tline3 = new Line3();\n\t\t\t\t\tplane = new Plane();\n\t\t\t\t\tclosestPoint = new Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar vertex, vertices = this.vertices;\n\t\t\t\tvar extremes = this.computeExtremes();\n\t\t\t\tvar min = extremes.min;\n\t\t\t\tvar max = extremes.max;\n\n\t\t\t\tvar v0, v1, v2, v3;\n\t\t\t\tvar i, l, j;\n\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t\t// (max.x - min.x)\n\t\t\t\t// (max.y - min.y)\n\t\t\t\t// (max.z - min.z)\n\n\t\t\t\tvar distance, maxDistance = 0;\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tindex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tv0 = min[ index ];\n\t\t\t\tv1 = max[ index ];\n\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\t\tmaxDistance = 0;\n\t\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\t\tmaxDistance = - 1;\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar faces = [];\n\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// the initial hull is the tetrahedron\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\t// Removes inactive faces\n\n\t\treindexFaces: function () {\n\n\t\t\tvar activeFaces = [];\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\tactiveFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.faces = activeFaces;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Finds the next vertex to create faces with the current hull\n\n\t\tnextVertexToAdd: function () {\n\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = vertex.next;\n\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\t\treturn eyeVertex;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t\t// For an edge to be part of the horizon it must join a face that can see\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\t\tthis.deleteFaceVertices( face );\n\n\t\t\tface.mark = Deleted;\n\n\t\t\tvar edge;\n\n\t\t\tif ( crossEdge === null ) {\n\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\t\tedge = crossEdge.next;\n\n\t\t\t}\n\n\t\t\tdo {\n\n\t\t\t\tvar twinEdge = edge.twin;\n\t\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== crossEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\t\tthis.faces.push( face );\n\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t\t},\n\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t\t//  horizon opposite face and the face on the left/right\n\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\t\tthis.newFaces = [];\n\n\t\t\tvar firstSideEdge = null;\n\t\t\tvar previousSideEdge = null;\n\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t\t// returns the right side edge\n\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t\t}\n\n\t\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t\t}\n\n\t\t\t// perform final join of new faces\n\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the hull\n\n\t\taddVertexToHull: function ( eyeVertex ) {\n\n\t\t\tvar horizon = [];\n\n\t\t\tthis.unassigned.clear();\n\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\t\treturn\tthis;\n\n\t\t},\n\n\t\tcleanup: function () {\n\n\t\t\tthis.assigned.clear();\n\t\t\tthis.unassigned.clear();\n\t\t\tthis.newFaces = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar vertex;\n\n\t\t\tthis.computeInitialHull();\n\n\t\t\t// add all available vertices gradually to the hull\n\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\t\tthis.addVertexToHull( vertex );\n\n\t\t\t}\n\n\t\t\tthis.reindexFaces();\n\n\t\t\tthis.cleanup();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction Face() {\n\n\t\tthis.normal = new Vector3();\n\t\tthis.midpoint = new Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tObject.assign( Face, {\n\n\t\tcreate: function ( a, b, c ) {\n\n\t\t\tvar face = new Face();\n\n\t\t\tvar e0 = new HalfEdge( a, face );\n\t\t\tvar e1 = new HalfEdge( b, face );\n\t\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t\t// join edges\n\n\t\t\te0.next = e2.prev = e1;\n\t\t\te1.next = e0.prev = e2;\n\t\t\te2.next = e1.prev = e0;\n\n\t\t\t// main half edge reference\n\n\t\t\tface.edge = e0;\n\n\t\t\treturn face.compute();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Face.prototype, {\n\n\t\tgetEdge: function ( i ) {\n\n\t\t\tvar edge = this.edge;\n\n\t\t\twhile ( i > 0 ) {\n\n\t\t\t\tedge = edge.next;\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\twhile ( i < 0 ) {\n\n\t\t\t\tedge = edge.prev;\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn edge;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar triangle;\n\n\t\t\treturn function compute() {\n\n\t\t\t\tif ( triangle === undefined ) triangle = new Triangle();\n\n\t\t\t\tvar a = this.edge.tail();\n\t\t\t\tvar b = this.edge.head();\n\t\t\t\tvar c = this.edge.next.head();\n\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\t\ttriangle.getNormal( this.normal );\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\t\tthis.area = triangle.getArea();\n\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) - this.constant;\n\n\t\t}\n\n\t} );\n\n\t// Entity for a Doubly-Connected Edge List (DCEL).\n\n\tfunction HalfEdge( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\tObject.assign( HalfEdge.prototype, {\n\n\t\thead: function () {\n\n\t\t\treturn this.vertex;\n\n\t\t},\n\n\t\ttail: function () {\n\n\t\t\treturn this.prev ? this.prev.vertex : null;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tlengthSquared: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tsetTwin: function ( edge ) {\n\n\t\t\tthis.twin = edge;\n\t\t\tedge.twin = this;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t// A vertex as a double linked list node.\n\n\tfunction VertexNode( point ) {\n\n\t\tthis.point = point;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.face = null; // the face that is able to see this vertex\n\n\t}\n\n\t// A double linked list that contains vertex nodes.\n\n\tfunction VertexList() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tObject.assign( VertexList.prototype, {\n\n\t\tfirst: function () {\n\n\t\t\treturn this.head;\n\n\t\t},\n\n\t\tlast: function () {\n\n\t\t\treturn this.tail;\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.head = this.tail = null;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex before the target vertex\n\n\t\tinsertBefore: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target.prev;\n\t\t\tvertex.next = target;\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.prev = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex after the target vertex\n\n\t\tinsertAfter: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target;\n\t\t\tvertex.next = target.next;\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.next = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a vertex to the end of the linked list\n\n\t\tappend: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a chain of vertices where 'vertex' is the head.\n\n\t\tappendChain: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\t\twhile ( vertex.next !== null ) {\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t}\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the linked list\n\n\t\tremove: function ( vertex ) {\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex.next;\n\n\t\t\t}\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex.prev;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\t\tremoveSubList: function ( a, b ) {\n\n\t\t\tif ( a.prev === null ) {\n\n\t\t\t\tthis.head = b.next;\n\n\t\t\t} else {\n\n\t\t\t\ta.prev.next = b.next;\n\n\t\t\t}\n\n\t\t\tif ( b.next === null ) {\n\n\t\t\t\tthis.tail = a.prev;\n\n\t\t\t} else {\n\n\t\t\t\tb.next.prev = a.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\treturn this.head === null;\n\n\t\t}\n\n\t} );\n\n\treturn ConvexHull;\n\n} )();\n\nexport { ConvexHull };\n","import { BufferAttribute, BufferGeometry, Mesh, Object3D, Quaternion, Vector3 } from 'three';\nimport type { Geometry } from 'three/examples/jsm/deprecated/Geometry';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _q1 = new Quaternion();\n\n/**\n* Returns a single geometry for the given object. If the object is compound,\n* its geometries are automatically merged. Bake world scale into each\n* geometry, because we can't easily apply that to the cannonjs shapes later.\n*/\nexport function getGeometry (object: Object3D): BufferGeometry | null {\n\tconst meshes = getMeshes(object);\n\tif (meshes.length === 0) return null;\n\n\t// Single mesh. Return, preserving original type.\n\tif (meshes.length === 1) {\n\t\treturn normalizeGeometry(meshes[0]);\n\t}\n\n\t// Multiple meshes. Merge and return.\n\tlet mesh: Mesh | undefined;\n\tconst geometries: BufferGeometry[] = [];\n\twhile ((mesh = meshes.pop())) {\n\t\tgeometries.push(simplifyGeometry(normalizeGeometry(mesh)));\n\t}\n\n\treturn mergeBufferGeometries(geometries);\n}\n\nfunction normalizeGeometry (mesh: Mesh): BufferGeometry {\n\tlet geometry: BufferGeometry = mesh.geometry;\n\tif ((geometry as unknown as Geometry).toBufferGeometry) {\n\t\tgeometry = (geometry as unknown as Geometry).toBufferGeometry();\n\t} else {\n\t\t// Preserve original type, e.g. CylinderBufferGeometry.\n\t\tgeometry = geometry.clone();\n\t}\n\n\tmesh.updateMatrixWorld();\n\tmesh.matrixWorld.decompose(_v1, _q1, _v2);\n\tgeometry.scale(_v2.x, _v2.y, _v2.z);\n\treturn geometry;\n}\n\n/**\n * Greatly simplified version of BufferGeometryUtils.mergeBufferGeometries.\n * Because we only care about the vertex positions, and not the indices or\n * other attributes, we throw everything else away.\n */\nfunction mergeBufferGeometries (geometries: BufferGeometry[]): BufferGeometry {\n\tlet vertexCount = 0;\n\tfor (let i = 0; i < geometries.length; i++) {\n\t\tconst position = geometries[i].attributes.position;\n\t\tif (position && position.itemSize === 3) {\n\t\t\tvertexCount += position.count;\n\t\t}\n\t}\n\n\tconst positionArray = new Float32Array(vertexCount * 3);\n\n\tlet positionOffset = 0;\n\tfor (let i = 0; i < geometries.length; i++) {\n\t\tconst position = geometries[i].attributes.position;\n\t\tif (position && position.itemSize === 3) {\n\t\t\tfor (let j = 0; j < position.count; j++) {\n\t\t\t\tpositionArray[positionOffset++] = position.getX(j);\n\t\t\t\tpositionArray[positionOffset++] = position.getY(j);\n\t\t\t\tpositionArray[positionOffset++] = position.getZ(j);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new BufferGeometry().setAttribute('position', new BufferAttribute(positionArray, 3));\n}\n\nexport function getVertices (geometry: BufferGeometry): Float32Array {\n\tconst position = geometry.attributes.position;\n\tconst vertices = new Float32Array(position.count * 3);\n\tfor (let i = 0; i < position.count; i += 3) {\n\t\tvertices[i] = position.getX(i);\n\t\tvertices[i + 1] = position.getY(i);\n\t\tvertices[i + 2] = position.getZ(i);\n\t}\n\treturn vertices;\n}\n\n/**\n* Returns a flat array of THREE.Mesh instances from the given object. If\n* nested transformations are found, they are applied to child meshes\n* as mesh.userData.matrix, so that each mesh has its position/rotation/scale\n* independently of all of its parents except the top-level object.\n*/\nfunction getMeshes (object: Object3D): Mesh[] {\n\tconst meshes: Mesh[] = [];\n\tobject.traverse(function (o) {\n\t\tif ((o as Mesh).isMesh) {\n\t\t\tmeshes.push(o as Mesh);\n\t\t}\n\t});\n\treturn meshes;\n}\n\nexport function getComponent(v: Vector3, component: string): number {\n\tswitch(component) {\n\t\tcase 'x': return v.x;\n\t\tcase 'y': return v.y;\n\t\tcase 'z': return v.z;\n\t}\n\tthrow new Error(`Unexpected component ${component}`);\n}\n\n/**\n* Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\n* attributes other than position.\n*\n* @param {THREE.BufferGeometry} geometry\n* @param {number} tolerance\n* @return {THREE.BufferGeometry>}\n*/\nfunction simplifyGeometry (geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex: {[key: string]: number} = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// Next value for triangle indices.\n\tlet nextIndex = 0;\n\n\tconst newIndices = [];\n\tconst newPositions = [];\n\n\t// Convert the error tolerance to an amount of decimal places to truncate to.\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'.\n\t\tlet hash = '';\n\n\t\t// Double tilde truncates the decimal value.\n\t\thash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\n\t\thash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\n\t\thash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index.\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\tnewPositions.push( positions.getX( index ) );\n\t\t\tnewPositions.push( positions.getY( index ) );\n\t\t\tnewPositions.push( positions.getZ( index ) );\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Construct merged BufferGeometry.\n\n\tconst positionAttribute = new BufferAttribute(\n\t\tnew Float32Array( newPositions ),\n\t\tpositions.itemSize,\n\t\tpositions.normalized\n\t);\n\n\tconst result = new BufferGeometry();\n\tresult.setAttribute( 'position', positionAttribute );\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n","import { Box, Quaternion as CQuaternion, ConvexPolyhedron, Cylinder, Shape, Sphere, Trimesh, Vec3 } from 'cannon-es';\nimport { Box3, BufferGeometry, CylinderGeometry, MathUtils, Mesh, Object3D, SphereGeometry, Vector3 } from 'three';\nimport { ConvexHull } from '../lib/ConvexHull.js';\nimport { getComponent, getGeometry, getVertices } from './utils.js';\n\nconst PI_2 = Math.PI / 2;\n\nexport enum ShapeType {\n\tBOX = 'Box',\n\tCYLINDER = 'Cylinder',\n\tSPHERE = 'Sphere',\n\tHULL = 'ConvexPolyhedron',\n\tMESH = 'Trimesh',\n}\n\nexport interface ShapeOptions {\n\ttype?: ShapeType,\n\tcylinderAxis?: 'x' | 'y' | 'z',\n\tsphereRadius?: number,\n}\n\nexport interface ShapeResult<T extends Shape = Shape> {\n\tshape: T,\n\toffset?: Vec3,\n\torientation?: CQuaternion\n}\n\n/**\n * Given a THREE.Object3D instance, creates a corresponding CANNON shape.\n */\nexport const threeToCannon = function (object: Object3D, options: ShapeOptions = {}): ShapeResult | null {\n\tlet geometry: BufferGeometry | null;\n\n\tif (options.type === ShapeType.BOX) {\n\t\treturn createBoundingBoxShape(object);\n\t} else if (options.type === ShapeType.CYLINDER) {\n\t\treturn createBoundingCylinderShape(object, options);\n\t} else if (options.type === ShapeType.SPHERE) {\n\t\treturn createBoundingSphereShape(object, options);\n\t} else if (options.type === ShapeType.HULL) {\n\t\treturn createConvexPolyhedron(object);\n\t} else if (options.type === ShapeType.MESH) {\n\t\tgeometry = getGeometry(object);\n\t\treturn geometry ? createTrimeshShape(geometry) : null;\n\t} else if (options.type) {\n\t\tthrow new Error(`[CANNON.threeToCannon] Invalid type \"${options.type}\".`);\n\t}\n\n\tgeometry = getGeometry(object);\n\tif (!geometry) return null;\n\n\tswitch (geometry.type) {\n\t\tcase 'BoxGeometry':\n\t\tcase 'BoxBufferGeometry':\n\t\t\treturn createBoxShape(geometry);\n\t\tcase 'CylinderGeometry':\n\t\tcase 'CylinderBufferGeometry':\n\t\t\treturn createCylinderShape(geometry as CylinderGeometry);\n\t\tcase 'PlaneGeometry':\n\t\tcase 'PlaneBufferGeometry':\n\t\t\treturn createPlaneShape(geometry);\n\t\tcase 'SphereGeometry':\n\t\tcase 'SphereBufferGeometry':\n\t\t\treturn createSphereShape(geometry as SphereGeometry);\n\t\tcase 'TubeGeometry':\n\t\tcase 'BufferGeometry':\n\t\t\treturn createBoundingBoxShape(object);\n\t\tdefault:\n\t\t\tconsole.warn(\n\t\t\t\t'Unrecognized geometry: \"%s\". Using bounding box as shape.', geometry.type\n\t\t\t);\n\t\t\treturn createBoxShape(geometry);\n\t}\n};\n\n/******************************************************************************\n * Shape construction\n */\n\nfunction createBoxShape (geometry: BufferGeometry): ShapeResult | null {\n\tconst vertices = getVertices(geometry);\n\n\tif (!vertices.length) return null;\n\n\tgeometry.computeBoundingBox();\n\tconst box = geometry.boundingBox!;\n\tconst shape = new Box(new Vec3(\n\t\t(box.max.x - box.min.x) / 2,\n\t\t(box.max.y - box.min.y) / 2,\n\t\t(box.max.z - box.min.z) / 2\n\t));\n\treturn {shape};\n}\n\n/** Bounding box needs to be computed with the entire subtree, not just geometry. */\nfunction createBoundingBoxShape (object: Object3D): ShapeResult | null {\n\tconst clone = object.clone();\n\tclone.quaternion.set(0, 0, 0, 1);\n\tclone.updateMatrixWorld();\n\n\tconst box = new Box3().setFromObject(clone);\n\n\tif (!isFinite(box.min.lengthSq())) return null;\n\n\tconst shape = new Box(new Vec3(\n\t\t(box.max.x - box.min.x) / 2,\n\t\t(box.max.y - box.min.y) / 2,\n\t\t(box.max.z - box.min.z) / 2\n\t));\n\n\tconst localPosition = box.translate(clone.position.negate()).getCenter(new Vector3());\n\n\treturn {\n\t\tshape,\n\t\toffset: localPosition.lengthSq()\n\t\t\t? new Vec3(localPosition.x, localPosition.y, localPosition.z)\n\t\t\t: undefined\n\t};\n}\n\n/** Computes 3D convex hull as a CANNON.ConvexPolyhedron. */\nfunction createConvexPolyhedron (object: Object3D): ShapeResult | null {\n\tconst geometry = getGeometry(object);\n\n\tif (!geometry) return null;\n\n\t// Perturb.\n\tconst eps = 1e-4;\n\tfor (let i = 0; i < geometry.attributes.position.count; i++) {\n\t\tgeometry.attributes.position.setXYZ(\n\t\t\ti,\n\t\t\tgeometry.attributes.position.getX(i) + (Math.random() - 0.5) * eps,\n\t\t\tgeometry.attributes.position.getY(i) + (Math.random() - 0.5) * eps,\n\t\t\tgeometry.attributes.position.getZ(i) + (Math.random() - 0.5) * eps,\n\t\t);\n\t}\n\n\t// Compute the 3D convex hull.\n\tconst hull = new ConvexHull().setFromObject(new Mesh(geometry));\n\tconst hullFaces = hull.faces;\n\tconst vertices = [];\n\tconst faces: number[][] = [];\n\n\tfor (let i = 0; i < hullFaces.length; i++) {\n\t\tconst hullFace = hullFaces[ i ];\n\t\tconst face: number[] = [];\n\t\tfaces.push(face);\n\n\t\tlet edge = hullFace.edge;\n\t\tdo {\n\t\t\tconst point = edge.head().point;\n\t\t\tvertices.push( new Vec3(point.x, point.y, point.z) );\n\t\t\tface.push(vertices.length - 1);\n\t\t\tedge = edge.next;\n\t\t} while ( edge !== hullFace.edge );\n\t}\n\n\tconst shape = new ConvexPolyhedron({vertices, faces});\n\treturn {shape};\n}\n\nfunction createCylinderShape (geometry: CylinderGeometry): ShapeResult | null {\n\tconst params = geometry.parameters;\n\n\tconst shape = new Cylinder(\n\t\tparams.radiusTop,\n\t\tparams.radiusBottom,\n\t\tparams.height,\n\t\tparams.radialSegments\n\t);\n\n\t// Include metadata for serialization.\n\t// TODO(cleanup): Is this still necessary?\n\tshape.radiusTop = params.radiusTop;\n\tshape.radiusBottom = params.radiusBottom;\n\tshape.height = params.height;\n\tshape.numSegments = params.radialSegments;\n\n\treturn {\n\t\tshape,\n\t\torientation: new CQuaternion()\n\t\t\t.setFromEuler(MathUtils.degToRad(-90), 0, 0, 'XYZ')\n\t\t\t.normalize()\n\t}\n}\n\nfunction createBoundingCylinderShape (object: Object3D, options: ShapeOptions): ShapeResult | null {\n\tconst axes = ['x', 'y', 'z'];\n\tconst majorAxis = options.cylinderAxis || 'y';\n\tconst minorAxes = axes.splice(axes.indexOf(majorAxis), 1) && axes;\n\tconst box = new Box3().setFromObject(object);\n\n\tif (!isFinite(box.min.lengthSq())) return null;\n\n\t// Compute cylinder dimensions.\n\tconst height = box.max[majorAxis] - box.min[majorAxis];\n\tconst radius = 0.5 * Math.max(\n\t\tgetComponent(box.max, minorAxes[0]) - getComponent(box.min, minorAxes[0]),\n\t\tgetComponent(box.max, minorAxes[1]) - getComponent(box.min, minorAxes[1]),\n\t);\n\n\t// Create shape.\n\tconst shape = new Cylinder(radius, radius, height, 12);\n\n\t// Include metadata for serialization.\n\tshape.radiusTop = radius;\n\tshape.radiusBottom = radius;\n\tshape.height = height;\n\tshape.numSegments = 12;\n\n\tconst eulerX = majorAxis === 'y' ? PI_2 : 0;\n\tconst eulerY = majorAxis === 'z' ? PI_2 : 0;\n\n\treturn {\n\t\tshape,\n\t\torientation: new CQuaternion()\n\t\t\t.setFromEuler(eulerX, eulerY, 0, 'XYZ')\n\t\t\t.normalize()\n\t};\n}\n\nfunction createPlaneShape (geometry: BufferGeometry): ShapeResult | null {\n\tgeometry.computeBoundingBox();\n\tconst box = geometry.boundingBox!;\n\tconst shape = new Box(new Vec3(\n\t\t(box.max.x - box.min.x) / 2 || 0.1,\n\t\t(box.max.y - box.min.y) / 2 || 0.1,\n\t\t(box.max.z - box.min.z) / 2 || 0.1\n\t));\n\treturn {shape};\n}\n\nfunction createSphereShape (geometry: SphereGeometry): ShapeResult | null {\n\tconst shape = new Sphere(geometry.parameters.radius);\n\treturn {shape};\n}\n\nfunction createBoundingSphereShape (object: Object3D, options: ShapeOptions): ShapeResult | null {\n\tif (options.sphereRadius) {\n\t\treturn {shape: new Sphere(options.sphereRadius)};\n\t}\n\tconst geometry = getGeometry(object);\n\tif (!geometry) return null;\n\tgeometry.computeBoundingSphere();\n\treturn {shape: new Sphere(geometry.boundingSphere!.radius)};\n}\n\nfunction createTrimeshShape (geometry: BufferGeometry): ShapeResult | null {\n\tconst vertices = getVertices(geometry);\n\n\tif (!vertices.length) return null;\n\n\tconst indices = Object.keys(vertices).map(Number);\n\treturn {shape: new Trimesh(vertices as unknown as number[], indices)};\n}\n"],"names":["ConvexHull","line3","plane","closestPoint","triangle","v1","Vector3","this","tolerance","faces","newFaces","assigned","VertexList","unassigned","vertices","Face","normal","midpoint","area","constant","outside","mark","edge","HalfEdge","vertex","face","prev","next","twin","VertexNode","point","head","tail","Object","assign","prototype","setFromPoints","points","Array","isArray","console","error","length","makeEmpty","i","l","push","compute","setFromObject","object","updateMatrixWorld","traverse","node","geometry","undefined","isGeometry","toBufferGeometry","BufferGeometry","fromGeometry","isBufferGeometry","attribute","attributes","position","count","fromBufferAttribute","applyMatrix4","matrixWorld","containsPoint","distanceToPoint","intersectRay","ray","target","tNear","Infinity","tFar","vN","origin","vD","dot","direction","t","Math","min","max","at","intersectsRay","addVertexToFace","append","insertBefore","removeVertexFromFace","remove","removeAllVerticesFromFace","start","end","removeSubList","deleteFaceVertices","absorbingFace","faceVertices","appendChain","nextVertex","resolveUnassignedPoints","isEmpty","first","maxDistance","maxFace","distance","computeExtremes","j","minVertices","maxVertices","copy","getComponent","setComponent","Number","EPSILON","abs","x","y","z","computeInitialHull","Line3","Plane","v0","v2","v3","extremes","index","set","closestPointToPoint","distanceToSquared","setFromCoplanarPoints","create","getEdge","setTwin","reindexFaces","activeFaces","nextVertexToAdd","eyeVertex","eyeFace","computeHorizon","eyePoint","crossEdge","horizon","twinEdge","oppositeFace","addAdjoiningFace","horizonEdge","addNewFaces","firstSideEdge","previousSideEdge","sideEdge","addVertexToHull","clear","cleanup","a","b","c","e0","e1","e2","Triangle","getNormal","getMidpoint","getArea","distanceTo","lengthSquared","last","insertAfter","_v1","_v2","_q1","Quaternion","getGeometry","meshes","o","isMesh","getMeshes","normalizeGeometry","mesh","geometries","pop","simplifyGeometry","vertexCount","itemSize","positionArray","Float32Array","positionOffset","getX","getY","getZ","setAttribute","BufferAttribute","mergeBufferGeometries","clone","decompose","scale","getVertices","v","component","Error","hashToIndex","indices","getIndex","positions","getAttribute","nextIndex","newIndices","newPositions","decimalShift","log10","shiftMultiplier","pow","hash","positionAttribute","normalized","result","setIndex","PI_2","PI","ShapeType","threeToCannon","options","type","BOX","createBoundingBoxShape","CYLINDER","axes","majorAxis","cylinderAxis","minorAxes","splice","indexOf","box","Box3","isFinite","lengthSq","height","radius","shape","Cylinder","radiusTop","radiusBottom","numSegments","eulerX","eulerY","orientation","CQuaternion","setFromEuler","normalize","createBoundingCylinderShape","SPHERE","sphereRadius","Sphere","computeBoundingSphere","boundingSphere","createBoundingSphereShape","HULL","eps","setXYZ","random","hullFaces","Mesh","hullFace","Vec3","ConvexPolyhedron","createConvexPolyhedron","MESH","keys","map","Trimesh","createTrimeshShape","createBoxShape","params","parameters","radialSegments","MathUtils","degToRad","createCylinderShape","computeBoundingBox","boundingBox","Box","createPlaneShape","createSphereShape","warn","quaternion","localPosition","translate","negate","getCenter","offset"],"mappings":"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"}